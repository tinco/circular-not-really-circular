#!/usr/bin/env ruby
require 'ripper'
require 'pp'

paths = ARGV.empty? ? ["."] : ARGV

def determine_build_order(paths)
  files = paths
    .flat_map {|p| list_files(p) }
    .select {|p| p.end_with?(".rb")}

  parsed_files = files.map {|p| parse(p) }
  build_context = parsed_files.map {|p| determine_definitions_and_references(p) }
  pp build_context
end

def determine_definitions_and_references(file)
  definitions_and_references = scan(file[:parsed][1]) # [:program, [..] ]


  file.merge! definitions_and_references

  file
end

def scan(tree)
  # we want to match a module, a class, constant or method definition
  # and add those to definitions
  definitions = {}
  references = []

  tree.each do |sexp|
    definition, body = match_definition(sexp)
    if definition
      definitions[definition] = {}
      
      if body
        result = scan(body)
        definitions[definition] = result[:definitions]
        result[:references].each do |r|
          # Each reference is a tuple of the name of the reference, and
          # its named scope
          references << [r[0], r[1].unshift(definition)]
        end
      end
    end
  end

  # we want to match constants and ident references and add those to references
  tree.each do |sexp|
    next unless sexp
    found_references =
      match_class_inheritance(sexp) ||
      match_command(sexp) ||
      match_expression(sexp)

    next unless found_references

    found_references.each do |reference|
      references << [reference,[]] if reference
    end
  end

  # inside those matches we want to recurse to find more definitions and references

  
  {
    definitions: definitions,
    references: references
  }
end

# Note these will have to be expressions that can be evaluated at compile time
def match_expression(sexp)
  # can a named scope be created inside an expression? if so
  # then this means we're going to have to track both at the
  # same time :(
  match_const_path(sexp) ||
    match_call(sexp) ||
    match_top_const(sexp) ||
    match_var_ref(sexp) ||
    match_assign(sexp) ||
    match_def_references(sexp) || # todo this isn't really an expression, but we'll have to modify the definitions thing to explore scopes without names or something to remove this here
    [] # etc..
end

def match_def_references(sexp)
  # [:def,
  #   [:@ident, "initialize", [5, 8]],
  #   [:params, nil, nil, nil, nil, nil, nil, nil],
  #   [:bodystmt, [[:void_stmt]], nil, nil, nil]]
  if sexp && sexp[0] == :def
    params = sexp[2][1..-1] # Todo find consts in params
    body = sexp[3][1]
    body.map {|e| match_expression(e)}.flatten
  end
end

def match_assign(sexp)
  if sexp && sexp[0] == :assign
    match_expression(sexp[1]) + match_expression(sexp[2])
  end
end

def match_var_ref(sexp)
  # [:var_ref, [:@const, "Game", [5, 12]]]
  if sexp && sexp[0] == :var_ref
    if sexp[1][0] == :@const
      [] << sexp[1][1]
    end
  end
end

def match_top_const(sexp)
  # [:top_const_ref, [:@const, "Accessiblity", [3, 14]]]
  if sexp && sexp[0] == :top_const_ref
    [] << "::" + sexp[1][1]
  end
end

def match_call(sexp)
  if sexp && sexp[0] == :call
    match_expression(sexp[1]) # TODO continue implementation
  end
end

# [:const_path_ref, [:var_ref, [:@const, "B1", [1, 0]]], [:@const, "B2", [1, 4]]]
def match_const_path(sexp)
  if sexp && sexp[0] == :const_path_ref
    # TODO what if it somehow references a constant that's not part of the
    # const path?
    prefix = match_expression(sexp[1])
    suffix = sexp[2][1]
    [] << (prefix << suffix).join("::")
  end
end

def match_command(sexp)
  if sexp && sexp[0] == :command
    # TODO research what else can be in a command
    args = sexp[2]
    args[1].flat_map {|a| match_expression(a)}.compact
  end
end

def match_class_inheritance(sexp)
  if sexp && sexp.first == :class
    match_expression(sexp[2]) # TODO untested
  end
end

def match_definition(sexp)
  match_class(sexp) || match_module(sexp) || match_constant(sexp) || match_method_definition(sexp)
end

def match_method_definition(sexp)
  nil # todo
end

def match_class(sexp)
  # [:class, [:const_ref ... ], nil, ... ]
  if sexp && sexp.first == :class
    [resolve_name(sexp[1]), sexp[3][1]]
  end
end

def match_module(sexp)
  # [:module, [:const_ref ... ], ... ]
  if sexp && sexp.first == :module
    [resolve_name(sexp[1]), sexp[2][1]]
  end
end

def match_constant(sexp)
  false
end

def resolve_name(sexp)
  if sexp[0] == :const_ref
    # [:const_ref, [:@const, "View", [1, 6]]],
    sexp[1][1]
  else
    raise "name not a const_ref"
  end
rescue
  puts "Could not resolve name: #{ sexp.inspect }"
end

def parse(file)
  {
    name: file,
    parsed: Ripper.sexp(File.read(file)),
    definitions: {},
    references: {}
  }
end

def list_files(path)
  Dir.glob("#{path}/**/*")
end

determine_build_order(paths)
